<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1421970050817">{:repl-history {:ide [], :local [&quot;(ns caves.core\n  (:require [lanterna.screen :as s]))\n\n\n(defn main [screen-type]\n  (let [screen (s/get-screen screen-type)]\n    (s/in-screen screen\n                 (s/put-string screen 0 0 \&quot;Welcome to the caves.\&quot;)\n                 (s/put-string screen 0 1 \&quot;Press any key to exit...‚\&quot;)\n                 (s/redraw screen)\n                 (s/get-key-blocking screen))))\n(defn -main\n  [&amp; args]\n  (let [args (set args)\n        scree-type (cond\n                     (args \&quot;:swing\&quot;) :swing\n                     (args \&quot;:text\&quot;) :text\n                     :else :auto)]\n    (main scree-type)))\n&quot; &quot;(letfn [\n        (twice [x] (* x 2))\n        (six-times [y] (* (twice y) 3))\n        ]\n  (println \&quot;Twice 15 = \&quot; (twice 15))\n  (println \&quot;Six tiems 15\&quot; (six-times 15))\n  )&quot; &quot;(letfn [\n        (twice [x] (* x 2))\n        (six-times [y] (* (twice y) 3))\n        ]\n  (println \&quot;Twice 15 =\&quot; (twice 15))\n  (println \&quot;Six tiems 15 =\&quot; (six-times 15))\n  )&quot; &quot;(letfn [\n        (twice [x] (* x 2))\n        (six-times [y] (* (twice y) 3))\n        ]\n  (println \&quot;Twice 15     =\&quot; (twice 15))\n  (println \&quot;Six tiems 15 =\&quot; (six-times 15))\n  )&quot; &quot;(ns caves.core\n  (:require [lanterna.screen :as s]))\n\n(defrecord UI [kind])\n(defrecord World [])\n(defrecord Game [world uis input])\n\n(defn clear-screen [screen]\n  (let [blank (apply str (repeat 80 \\space))]\n    (doseq [row (range 24)]\n      (s/put-string screen 0 row blank))))\n\n(defmulti draw-ui\n          (fn [ui game screen]\n            (:kind ui)))\n(defmethod draw-ui :start [ui game screen]\n  (s/put-string screen 0 0 \&quot;Welcom to the game.\&quot;)\n  (s/put-string screen 0 1 \&quot;Press enter to win, anything else to lose.\&quot;))\n(defmethod draw-ui :win [ui game screen]\n  (s/put-string screen 0 0 \&quot;Congrats, you win!\&quot;)\n  (s/put-string screen 0 1 \&quot;Press esc to exit, anything else to restart.\&quot;))\n(defmethod draw-ui :lose [ui game screen]\n  (s/put-string screen 0 0 \&quot;Sorry, you lose.\&quot;)\n  (s/put-string screen 0 1 \&quot;Press esc to exit, anything else to restart.\&quot;))\n\n(defn draw-game [game screen]\n  (clear-screen screen)\n  (doseq [ui (:uis game)]\n    (draw-ui ui game screen))\n  (s/redraw screen))\n\n(defmulti process-input\n          (fn [game input]\n            (:kind (last (:uis game)))))\n(defmethod process-input :start [game input]\n  (if (= input :enter)\n    (assoc game :uis [(new UI :win)])\n    (assoc game :uis [(new UI :lose)])))\n(defmethod process-input :win [game input]\n  (if (= input :escape)\n    (assoc game :uis [])\n    (assoc game :uis [(new UI :start)])))\n(defmethod process-input :lose [game input]\n  (if (= input :escape)\n    (assoc game :uis [])\n    (assoc game :uis [(new UI :start)])))\n\n(defn get-input [game screen]\n  (assoc game :input (s/get-key-blocking screen)))\n\n(defn run-game [game screen]\n  (loop [{:keys [input uis] :as game} game]\n    (when-not (empty? uis)\n      (draw-game game screen)\n      (if (nil? input)\n        (recur (get-input game screen))\n        (recur (process-input (dissoc game :input) input))))))\n\n(defn new-game []\n  (new Game (new World)\n       [(new UI :start)]\n       nil))\n\n(defn main\n  ([screen-type]\n    (main screen-type false))\n  ([screen-type block?]\n    (leftfn [\n             (go []\n                 (let [screen (s/get-screen screen-type)]\n                   (s/in-screen screen (run-game (new-game) screen))))\n             ]\n            (if block?\n              (go)\n              (future (go))))))\n\n\n(defn main [screen-type]\n  (let [screen (s/get-screen screen-type)]\n    (s/in-screen screen\n                 (s/put-string screen 0 0 \&quot;Welcome to the caves.\&quot;)\n                 (s/put-string screen 0 1 \&quot;Press any key to exit...‚\&quot;)\n                 (s/redraw screen)\n                 (s/get-key-blocking screen))))\n(defn -main\n  [&amp; args]\n  (let [args (set args)\n        scree-type (cond\n                     (args \&quot;:swing\&quot;) :swing\n                     (args \&quot;:text\&quot;) :text\n                     :else :auto)]\n    (main scree-type)))\n\n(main :swing)&quot; &quot;(ns caves.core\n  (:require [lanterna.screen :as s]))\n\n(defrecord UI [kind])\n(defrecord World [])\n(defrecord Game [world uis input])\n\n(defn clear-screen [screen]\n  (let [blank (apply str (repeat 80 \\space))]\n    (doseq [row (range 24)]\n      (s/put-string screen 0 row blank))))\n\n(defmulti draw-ui\n          (fn [ui game screen]\n            (:kind ui)))\n(defmethod draw-ui :start [ui game screen]\n  (s/put-string screen 0 0 \&quot;Welcom to the game.\&quot;)\n  (s/put-string screen 0 1 \&quot;Press enter to win, anything else to lose.\&quot;))\n(defmethod draw-ui :win [ui game screen]\n  (s/put-string screen 0 0 \&quot;Congrats, you win!\&quot;)\n  (s/put-string screen 0 1 \&quot;Press esc to exit, anything else to restart.\&quot;))\n(defmethod draw-ui :lose [ui game screen]\n  (s/put-string screen 0 0 \&quot;Sorry, you lose.\&quot;)\n  (s/put-string screen 0 1 \&quot;Press esc to exit, anything else to restart.\&quot;))\n\n(defn draw-game [game screen]\n  (clear-screen screen)\n  (doseq [ui (:uis game)]\n    (draw-ui ui game screen))\n  (s/redraw screen))\n\n(defmulti process-input\n          (fn [game input]\n            (:kind (last (:uis game)))))\n(defmethod process-input :start [game input]\n  (if (= input :enter)\n    (assoc game :uis [(new UI :win)])\n    (assoc game :uis [(new UI :lose)])))\n(defmethod process-input :win [game input]\n  (if (= input :escape)\n    (assoc game :uis [])\n    (assoc game :uis [(new UI :start)])))\n(defmethod process-input :lose [game input]\n  (if (= input :escape)\n    (assoc game :uis [])\n    (assoc game :uis [(new UI :start)])))\n\n(defn get-input [game screen]\n  (assoc game :input (s/get-key-blocking screen)))\n\n(defn run-game [game screen]\n  (loop [{:keys [input uis] :as game} game]\n    (when-not (empty? uis)\n      (draw-game game screen)\n      (if (nil? input)\n        (recur (get-input game screen))\n        (recur (process-input (dissoc game :input) input))))))\n\n(defn new-game []\n  (new Game (new World)\n       [(new UI :start)]\n       nil))\n\n(defn main\n  ([screen-type]\n    (main screen-type false))\n  ([screen-type block?]\n    (letfn [\n             (go []\n                 (let [screen (s/get-screen screen-type)]\n                   (s/in-screen screen (run-game (new-game) screen))))\n             ]\n            (if block?\n              (go)\n              (future (go))))))\n\n\n(defn main [screen-type]\n  (let [screen (s/get-screen screen-type)]\n    (s/in-screen screen\n                 (s/put-string screen 0 0 \&quot;Welcome to the caves.\&quot;)\n                 (s/put-string screen 0 1 \&quot;Press any key to exit...‚\&quot;)\n                 (s/redraw screen)\n                 (s/get-key-blocking screen))))\n(defn -main\n  [&amp; args]\n  (let [args (set args)\n        scree-type (cond\n                     (args \&quot;:swing\&quot;) :swing\n                     (args \&quot;:text\&quot;) :text\n                     :else :auto)]\n    (main scree-type)))\n\n(main :swing)&quot; &quot;(main :text)&quot; &quot;(defn main\n  ([screen-type]\n    (main screen-type false))\n  ([screen-type block?]\n    (letfn [\n             (go []\n                 (let [screen (s/get-screen screen-type)]\n                   (s/in-screen screen (run-game (new-game) screen))))\n             ]\n            (if block?\n              (go)\n              (future (go))))))&quot; &quot;(main :swing)&quot;], :remote []}}</component>
</project>